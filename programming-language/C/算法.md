# C 语言常用算法

## 排序算法
四个排序算法的时间/空间复杂度  
冒泡排序 O(n^2) /  O(1)  
选择排序 O(n^2) / O(1)  
插入排序 O(n^2) / O(1)  
快速排序 O(nlogn) / O(logn)  
### 冒泡排序  
冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。  

```c
void bubbleSort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i < n - 1; i++) {
        // 每轮比较后，最大的元素会移到最后,所以最后一个值不用比较，下一次少一个元素
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

### 选择排序 
选择排序的核心思想是每次从未排序的部分中找到最小（或最大）元素，将其放到已排序部分的末尾。  
```c
void selectionSort(int arr[], int n) {
    int i, j, min_idx, temp;
    for (i = 0; i < n - 1; i++) {
        // 找到未排序部分的最小元素
        min_idx = i;
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        // 交换最小元素到正确位置
        temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}
```

### 插入排序  
插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  
```c
void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];  // 当前要插入的元素
        j = i - 1;     // 已排序部分的最后一个元素索引
        // 将大于key的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 插入key到正确位置
        arr[j + 1] = key;
    }
}
```


### 快速排序  
```c
// 分区函数 - 将数组分为两部分
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准
    int i = (low - 1);      // 较小元素的索引
    
    for (int j = low; j < high; j++) {
        // 如果当前元素小于或等于基准
        if (arr[j] <= pivot) {
            i++;  // 增加较小元素的索引
            // 交换元素
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    
    // 将基准元素放到正确位置
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    
    return (i + 1);  // 返回基准元素的正确位置
}

// 快速排序主函数
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // 获取分区索引
        int pi = partition(arr, low, high);
        
        // 递归排序基准元素左边的子数组
        quickSort(arr, low, pi - 1);
        // 递归排序基准元素右边的子数组
        quickSort(arr, pi + 1, high);
    }
}

// 便于使用的包装函数
void quickSortWrapper(int arr[], int n) {
    quickSort(arr, 0, n - 1);
}
```

## 斐波那契数列  

### 递归实现 
时间复杂度 **O(2^n)** 空间复杂度 O(n) 
```c 
int fibonacci_recursive(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    }
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2);
}
```

### 迭代实现  
时间复杂度 O(n)，空间复杂度 O(1)
```c
int fibonacci_iterative(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    }

    int prev1 = 0;  // F(0)
    int prev2 = 1;  // F(1)
    int current;
    
    for (int i = 2; i <= n; i++) {
        current = prev1 + prev2;
        prev1 = prev2;
        prev2 = current;
    }
    return current;
}
```
